using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net.Sockets;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;
using CsvHelper;
using Newtonsoft.Json;

namespace OelianderUI.Helpers.Exploits
{
    public class OpenSSHServerVuln
    {
        /// 
        /// Remote Unauthenticated Code Execution Vulnerability in OpenSSH server [CVE-2024-6387]
        /// 
        internal static readonly string ShodanSearchPattern = "product:\"OpenSSH\"";
        private static async Task<bool> IsPortOpen(string ip, int port, TimeSpan timeout)
        {
            try
            {
                using (var client = new TcpClient())
                {
                    var connectTask = client.ConnectAsync(ip, port);
                    if (await Task.WhenAny(connectTask, Task.Delay(timeout)) == connectTask)
                    {
                        return true;
                    }
                }
            }
            catch
            {
                return false;
            }

            return false;
        }

        private static async Task<string> GetSshBanner(string ip, int port, TimeSpan timeout)
        {
            try
            {
                using (var client = new TcpClient())
                {
                    var connectTask = client.ConnectAsync(ip, port);
                    if (await Task.WhenAny(connectTask, Task.Delay(timeout)) == connectTask)
                    {
                        using (var stream = client.GetStream())
                        {
                            var buffer = new byte[1024];
                            var bytesRead = await stream.ReadAsync(buffer, 0, buffer.Length);
                            return System.Text.Encoding.UTF8.GetString(buffer, 0, bytesRead).Trim();
                        }
                    }
                }
            }
            catch
            {
                Objects.ShowAlert("Error", "Unable to fetch SSH Banner", 2);
            }
            return null;
        }

        private static async Task CheckVulnerability(string ip, int port, TimeSpan timeout, Queue<string> resultQueue)
        {
            if (!await IsPortOpen(ip, port, timeout))
            {
                resultQueue.Enqueue($"{ip}:{port} closed - Port closed");
                return;
            }

            var banner = await GetSshBanner(ip, port, timeout);
            var vulnerableVersions = new List<string>
            {
                "OpenSSH_8.5p1", "OpenSSH_8.6p1", "OpenSSH_8.7p1", "OpenSSH_8.8p1",
                "OpenSSH_8.9p1", "OpenSSH_9.0p1", "OpenSSH_9.1p1", "OpenSSH_9.2p1",
                "OpenSSH_9.3p1", "OpenSSH_9.4p1", "OpenSSH_9.5p1", "OpenSSH_9.6p1", "OpenSSH_9.7p1"
            };

            if (vulnerableVersions.Any(version => banner?.Contains(version) == true))
            {
                resultQueue.Enqueue($"{ip}:{port} vulnerable - (running {banner})");
            }
            else
            {
                resultQueue.Enqueue($"{ip}:{port} not_vulnerable - (running {banner})");
            }
        }

        private static void SaveResults(string outputFile, string outputFormat, List<string> vulnerable, List<string> notVulnerable)
        {
            switch (outputFormat.ToLower())
            {
                case "csv":
                    using (var writer = new StreamWriter(outputFile))
                    using (var csv = new CsvWriter(writer, System.Globalization.CultureInfo.InvariantCulture))
                    {
                        csv.WriteRecords(vulnerable.Select(v => new { IP = v, Status = "Vulnerable" }).Union(
                                         notVulnerable.Select(nv => new { IP = nv, Status = "Not Vulnerable" })));
                    }
                    Console.WriteLine($"✅ Results saved to {outputFile} in CSV format.");
                    break;

                case "json":
                    var jsonOutput = new
                    {
                        Vulnerable = vulnerable,
                        NotVulnerable = notVulnerable
                    };
                    File.WriteAllText(outputFile, JsonConvert.SerializeObject(jsonOutput, Formatting.Indented));
                    Console.WriteLine($"✅ Results saved to {outputFile} in JSON format.");
                    break;

                case "txt":
                    File.WriteAllLines(outputFile, vulnerable.Concat(notVulnerable));
                    Objects.ShowAlert("Exploit Failed", $"✅ Results saved to {outputFile} in TXT format.", 2);
                    break;
            }
        }

        private static async Task ScanPorts(IEnumerable<string> targets, int port, TimeSpan timeout, string outputFormat, string outputFile)
        {
            var resultQueue = new Queue<string>();
            var tasks = new List<Task>();

            foreach (var target in targets)
            {
                tasks.Add(CheckVulnerability(target, port, timeout, resultQueue));
            }

            await Task.WhenAll(tasks);

            var vulnerable = resultQueue.Where(x => x.Contains("vulnerable")).ToList();
            var notVulnerable = resultQueue.Where(x => x.Contains("not_vulnerable")).ToList();
            var closedPorts = resultQueue.Count(x => x.Contains("closed"));

            Objects.ShowAlert("Exploit Failed", $"\nNo vulnerable server found: {notVulnerable.Count}", 2);
            foreach (var ip in notVulnerable)
            {
                Objects.ShowAlert("Exploit Failed", $"[+] No Vulnerable server found at {ip}", 2);
            }
            foreach (var ip in vulnerable)
            {
                Objects.ShowAlert("Vulnerability Confirmed", $"[+] Vulnerable server found at {ip}", 0);
            }

            Console.WriteLine($"\nSummary:");
            Console.WriteLine($"Total targets: {targets.Count()} servers");
            Console.WriteLine($"Vulnerable: {vulnerable.Count} servers");
            Console.WriteLine($"Not vulnerable: {notVulnerable.Count} servers");
            Console.WriteLine($"Port {port} closed: {closedPorts} servers");

            if (!string.IsNullOrEmpty(outputFile))
            {
                SaveResults(outputFile, outputFormat, vulnerable, notVulnerable);
            }
        }

        private static void ExploitVulnerability(IEnumerable<string> targets, int port)
        {
            // Uncomment to call the C function for exploiting the vulnerability
            // string targetStr = string.Join(",", targets);
            // var result = ExploitVulnerability(targetStr, port);

            // Assuming the result is based on the C function call (for now, just mock result)
            Console.WriteLine($"Exploiting vulnerabilities...");
            Console.WriteLine("Exploitation successful!");
        }

        static void ScanForSSHVuln(string targetString, int port = 22)
        {
            var banner = $@"
██████╗ ██████╗ ███████╗███╗   ██╗███████╗███████╗██╗  ██╗
██╔═══██╗██╔══██╗██╔════╝████╗  ██║██╔════╝██╔════╝██║  ██║
██║   ██║██████╔╝█████╗  ██╔██╗ ██║███████╗███████╗███████║
██║   ██║██╔═══╝ ██╔══╝  ██║╚██╗██║╚════██║╚════██║██╔══██║
╚██████╔╝██║     ███████╗██║ ╚████║███████║███████║██║  ██║
 ╚═════╝ ╚═╝     ╚══════╝╚═╝  ╚═══╝╚══════╝╚══════╝╚═╝  ╚═╝
";
            IEnumerable<string> targets;
            if (targetString.EndsWith(".txt"))
                targets = File.ReadAllLines(targetString);
            else
            {
                File.WriteAllText("temp", targetString);
                targets = File.ReadAllLines("temp");
                File.Delete("temp");
            }

            ScanPorts(targets, port, TimeSpan.FromSeconds(3000), "csv", "Results/OpenSSH/Results.csv").GetAwaiter().GetResult();

            //else if (options.Exploit)
            //{
            //    ExploitVulnerability(options.Targets, options.Port);
            //}
            //else
            //{
            //    Console.WriteLine("Please specify either --scan or --exploit option.");
            //}
        }
    }
}
